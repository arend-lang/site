<html><head><title>OuterMeasureRing</title><link rel="stylesheet" href="OuterMeasureRingHTML/Arend.css"></head><body><pre class="Arend"><a id="914546" class="BLOCK_COMMENT">{- TODO[server2]: Delete or rewrite this&#10;\import Algebra.Group&#10;\import Algebra.Group.GroupHom&#10;\import Algebra.Meta&#10;\import Algebra.Monoid&#10;\import Algebra.Ordered&#10;\import Algebra.Pointed&#10;\import Algebra.Ring.Boolean&#10;\import Algebra.Semiring&#10;\import Analysis.Measure.MeasureRing&#10;\import Arith.Rat&#10;\import Arith.Real&#10;\import Arith.Real.Field&#10;\import Arith.Real.InfReal&#10;\import Arith.Real.LowerReal&#10;\import Function.Meta&#10;\import Logic&#10;\import Logic.Meta&#10;\import Meta&#10;\import Order.Biordered&#10;\import Order.Lattice&#10;\import Order.PartialOrder&#10;\import Order.StrictOrder&#10;\import Paths&#10;\import Paths.Meta&#10;\import Set.Filter&#10;\import Set.Subset&#10;\import Topology.CoverSpace.Complete&#10;\import Topology.MetricSpace.ExtendedMetricSpace&#10;\import Topology.MetricSpace.ValuedMetricSpace&#10;\import Topology.NormedAbGroup&#10;\import Topology.NormedAbGroup.ExtendedNormedAbGroup&#10;\import Topology.NormedAbGroup.ValuedNormedAbGroup&#10;\import Topology.TopSpace&#10;\import Topology.UniformSpace.Complete&#10;\import Topology.UniformSpace.InfReal&#10;&#10;\class LowerPseudoNormedAbGroup \extends ValuedPseudoNormedAbGroup&#10;  | V =&gt; ExtendedPseudoMetricSpace.LowerRealMetricValueOrder&#10;&#10;\class PseudoOuterPremeasureRing \extends BooleanPseudoRing, ValuedPseudoNormedAbGroup&#10;  | V =&gt; ExtendedPseudoMetricSpace.LowerRealMetricValueOrder&#10;  | norm-outer-measure {x y : E} : norm (x ∨ y) LowerRealAbMonoid.&lt;= norm x LowerRealAbMonoid.+ norm y&#10;  | norm-outer-mono {x y : E} : x &lt;= y -&gt; norm x LowerRealAbMonoid.&lt;= norm y&#10;  | norm_negative =&gt; pmap norm neative=id&#10;  | norm_+ =&gt; rewrite +_diff $ norm-outer-measure LowerRealAbMonoid.&lt;=∘ LowerRealAbMonoid.&lt;=_+ (norm-outer-mono diff_&lt;=) (norm-outer-mono diff_&lt;=)&#10;&#10;-- TODO: Replace with relative completion&#10;\class ExtendedMeasure \noclassifying (R : LowerPseudoNormedAbGroup) (M : PremeasurePseudoRing) (inc : AddGroupHom M R) (comp : \Pi (a : M) -&gt; norm a LowerRealAbMonoid.&lt;= norm (inc a)) {&#10;  \func IsMeasurable (a : R) : \Prop&#10;    =&gt; ∃ (F : ProperFilter M) (R.IsFilterLimit (SetFilter-map inc F) a)&#10;&#10;  \lemma measurable-cauchy {F : ProperFilter M} (Fc : IsCauchyFilter (SetFilter-map inc F)) : IsCauchyFilter (SetFilter-map norm F)&#10;    =&gt; (cauchyFilter-uniform-char {InfRealUniformSpace}).2 \lam (inP (eps,B,eps&gt;0,V0,CV0,BV0,h)) =&gt; \case cauchyFilter-uniform-char.1 Fc (R.metricUniform $ RealAbGroup.lower_&lt;-char.2 $ half&gt;0 eps&gt;0) \with {&#10;      | inP (_, inP (a,idp), Fa) =&gt; unfold $ unfold at Fa $ \case F.isProper Fa \with {&#10;        | inP (x,ax&lt;eps/2) =&gt;&#10;          \have aux {y} (ay&lt;eps/2 : dist a (inc y) &lt; half eps) =&gt; inf-real_&lt;_LowerReal.2 $ transportInv (`&lt; _) M.norm-dist $ comp _ LowerRealAbMonoid.&lt;∘r transport2 (&lt;) (norm-dist *&gt; inv (pmap norm inc.func-minus)) (inv {LowerReal} RealAbGroup.+-lower *&gt; {LowerReal} half+half) (R.dist-triang &lt;∘r LowerRealAbMonoid.&lt;_+ (transportInv (LowerRealAbMonoid.`&lt; _) dist-symm ax&lt;eps/2) ay&lt;eps/2)&#10;          \in \case inf-real-located {norm x} {B + eps} {B + eps * 2} linarith \with {&#10;            | byLeft |x|&gt;B+eps =&gt; inP (V0, CV0, filter-mono Fa \lam {y} ay&lt;eps/2 =&gt; unfold (^-1) at ay&lt;eps/2 $ BV0 \case |x|&gt;B+eps \with {&#10;              | inP (B',B+eps&lt;B',B'&lt;|x|) =&gt; \case inf-real-located {norm y} {B} {B' - {RealAbGroup} eps} $ linarith (real_&lt;_U.2 B+eps&lt;B') \with {&#10;                | byLeft r =&gt; r&#10;                | byRight |y|&lt;B'-eps =&gt; absurd $ InfRealAbMonoid.&lt;-irreflexive {B'} $ InfRealAbMonoid.&lt;_L.2 B'&lt;|x| &lt;∘ norm_dist-bound {_} {x} {y} &lt;∘r transport (_ &lt;) (inv RealAbGroup.+-inf *&gt; RealAbGroup.+-comm *&gt; +-assoc *&gt; pmap (B' RealAbGroup.+) negative-left *&gt; RealAbGroup.zro-right) (InfRealAbMonoid.&lt;_+ (aux ay&lt;eps/2) |y|&lt;B'-eps)&#10;              }&#10;            })&#10;            | byRight |x|&lt;B+2eps =&gt;&#10;              \let x' : M.Bounded =&gt; (x, inP (_, |x|&lt;B+2eps))&#10;              \in \case h (norm x') \with {&#10;                | inP (U,CU,g) =&gt; inP (U, CU, filter-mono Fa \lam {y} ay&lt;eps/2 =&gt; unfold (^-1) at ay&lt;eps/2 $ unfolds&#10;                  \let y' : M.Bounded =&gt; (y, dist-bounded (aux ay&lt;eps/2) x'.2)&#10;                  \in g {norm y'} $ norm_-_abs {_} {x'} {y'} &lt;∘r real_&lt;_InfReal.2 (later $ transport {InfReal} (`&lt; _) M.norm-dist $ aux ay&lt;eps/2))&#10;              }&#10;          }&#10;      }&#10;    }&#10;&#10;  \lemma measure-pair {a : R} (m : IsMeasurable a) : Given (v : InfReal) ∃ (F : ProperFilter M) (R.IsFilterLimit (SetFilter-map inc F) a) (TopSpace.IsFilterLimit (SetFilter-map norm F) v)&#10;    \level \lam (u, inP s1) (v, inP s2) =&gt;&#10;      \have aux {u v : InfReal} {F1 : ProperFilter M} (F1a : R.IsFilterLimit (SetFilter-map inc F1) a) (F1u : TopSpace.IsFilterLimit (SetFilter-map norm F1) u)&#10;                                {F2 : ProperFilter M} (F2a : R.IsFilterLimit (SetFilter-map inc F2) a) (F2v : TopSpace.IsFilterLimit (SetFilter-map norm F2) v)&#10;                                (v&lt;u : v &lt; u) : Empty&#10;        =&gt; \let | (inP (q,v&lt;q,q&lt;u)) =&gt; v&lt;u&#10;                | (inP (r,r&lt;u,q&lt;r)) =&gt; L-rounded q&lt;u&#10;                | eps =&gt; r - {RealAbGroup} q&#10;                | eps&gt;0 : 0 &lt; eps =&gt; linarith (rat_real_&lt;.1 q&lt;r)&#10;                | v' =&gt; inf-real-real v {q} (InfRealAbMonoid.&lt;_U.2 v&lt;q)&#10;           \in F1.isWeaklyProper $ filter-mono (filter-meet (F1a OBall-open $ OBall-center $ (RealAbGroup.lower_&lt;-char {0} {eps * ratio 1 4}).2 linarith) (F1u (infReal-half-open r) (InfRealAbMonoid.&lt;_L.2 r&lt;u))) \lam {x1} VWx1 =&gt; absurd $&#10;               F2.isWeaklyProper $ filter-mono (filter-meet (F2a OBall-open $ OBall-center $ (RealAbGroup.lower_&lt;-char {0} {eps * ratio 1 4}).2 linarith) (F2v (infReal-ball-open (half eps) v') (inP (v', idp, rewrite (negative-right,RealAbGroup.abs_zro) $ half&gt;0 eps&gt;0)))) \lam {x2} VWx2 =&gt; absurd&#10;                \have | |x1-x2|&lt;eps/2 =&gt; comp (x1 - x2) LowerRealAbMonoid.&lt;∘r transport2 (&lt;) (R.norm-dist *&gt; inv (pmap norm inc.func-minus)) (inv {LowerReal} $ (pmap (eps *) (inv RealAbGroup.+-rat) *&gt; ldistr) *&gt; {LowerReal} RealAbGroup.+-lower) (R.dist-triang &lt;∘r LowerRealAbMonoid.&lt;_+ (transport (LowerRealAbMonoid.`&lt; _) dist-symm VWx1.1) VWx2.1)&#10;                      | (inP (|x2|,p2,e2')) =&gt; VWx2.2&#10;                      | |x2|&lt;eps/2+v' : |x2| &lt; half eps + v' =&gt; linarith (RealAbGroup.abs&gt;=id &lt;∘r e2')&#10;                \in linarith $ usingOnly (real_&lt;_InfReal.2 $ VWx1.2 InfRealAbMonoid.&lt;∘ transportInv (_ &lt;) RealAbGroup.+-inf (simplify in M.norm_+ &lt;∘r InfRealAbMonoid.&lt;_+ (inf-real_&lt;_LowerReal.2 |x1-x2|&lt;eps/2) (rewrite p2 in real_&lt;_InfReal.1 |x2|&lt;eps/2+v')), real_&lt;_U.2 (later v&lt;q) : v' &lt; q)&#10;      \in ext $ &lt;=-antisymmetric (aux s1.2 s1.3 s2.2 s2.3) (aux s2.2 s2.3 s1.2 s1.3)&#10;    \elim m&#10;    | inP (F,al) =&gt; \let CF =&gt; \new CauchyFilter InfRealUniformSpace {&#10;      | ProperFilter =&gt; ProperFilter-map norm F&#10;      | isCauchyFilter {C} =&gt; measurable-cauchy (filter-limit-cauchy al) {C}&#10;    } \in (CompleteCoverSpace.filter-point CF, inP (F, al, CompleteCoverSpace.filter-point-limit))&#10;&#10;  {-&#10;  \lemma measurable-closed {a b c : R} (op : M -&gt; M -&gt; M) (am : IsMeasurable a) (bm : IsMeasurable b) : IsMeasurable c \elim am, bm&#10;    | inP (F,Fa), inP (G,Gb) =&gt;&#10;      \let H : ProperFilter M =&gt; \new ProperFilter {&#10;        | F W =&gt; ∃ (U : Set M) (F U) (V : Set M) (G V) ∀ {x : U} {y : V} (W (op x y))&#10;        | filter-mono (inP (U,FU,V,GV,h)) p =&gt; inP (U, FU, V, GV, \lam Ux Vy =&gt; p (h Ux Vy))&#10;        | filter-top =&gt; inP (top, filter-top, top, filter-top, \lam _ _ =&gt; ())&#10;        | filter-meet (inP (U,FU,V,GV,h)) (inP (U',FU',V',GV',h')) =&gt; inP (U ∧ U', filter-meet FU FU', V ∧ V', filter-meet GV GV', \lam s t =&gt; (h s.1 t.1, h' s.2 t.2))&#10;        | isProper {W} (inP (U,FU,V,GV,h)) =&gt; \case isProper FU, isProper GV \with {&#10;          | inP (x,Ux), inP (y,Vy) =&gt; inP (op x y, h Ux Vy)&#10;        }&#10;      }&#10;      \in inP (H, \lam {W} Wo Wc =&gt; inP {?})&#10;&#10;  \lemma measurable-closed' {a b : R} (op : R -&gt; R -&gt; R) (am : IsMeasurable a) (bm : IsMeasurable b) : IsMeasurable (op a b) \elim am, bm&#10;    | inP (F,Fa), inP (G,Gb) =&gt;&#10;      \let H : ProperFilter M =&gt; \new ProperFilter {&#10;        | F W =&gt; ∃ (U : Set M) (F U) (V : Set M) (G V) ∀ {x : U} {y : V} {z} (inc z = op (inc x) (inc y) -&gt; W z)&#10;        | filter-mono (inP (U,FU,V,GV,h)) p =&gt; inP (U, FU, V, GV, \lam Ux Vy q =&gt; p (h Ux Vy q))&#10;        | filter-top =&gt; inP (top, filter-top, top, filter-top, \lam _ _ _ =&gt; ())&#10;        | filter-meet (inP (U,FU,V,GV,h)) (inP (U',FU',V',GV',h')) =&gt; inP (U ∧ U', filter-meet FU FU', V ∧ V', filter-meet GV GV', \lam s t q =&gt; (h s.1 t.1 q, h' s.2 t.2 q))&#10;        | isProper {W} (inP (U,FU,V,GV,h)) =&gt; \case isProper FU, isProper GV \with {&#10;          | inP (x,Ux), inP (y,Vy) =&gt; inP {?}&#10;        }&#10;      }&#10;      \in inP (H, \lam {W} Wo Wc =&gt; inP {?})&#10;  -}&#10;}&#10;-}</a><script src="OuterMeasureRingHTML/highlight-hover.js"></script></pre></body></html>